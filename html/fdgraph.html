<html><head><title>Index</title>
<style>

.node {
  stroke: #fff;
  stroke-width: 1.5px;
}

.link {
  stroke: #999;
  stroke-opacity: .6;
}

</style>
<link rel="stylesheet" href="ct.css" type="text/css">
</head><body>
<a href="index.html">Back to Index</a><br/>
<div id="mapDiv"></div>
<p id="downloadEle"></p>
The below functions should be run automatically<br>
Peer Map - export
<button onclick="bridge.runPythonFile('python/dumpanonconnections.py')">dump my peers</button> this will dump your peer fingerprint list to a file in your downloads directory (which is hopefully shared in some way)<br>
Try refreshing after dumping your peer list - may need to wait/force a RS file check<br>
<button onclick="downloadMore()">Download Data</button> download friends lists<br>


<script src="zepto.min.js"></script>

<script src="d3.v3.min.js"></script>
<script src="libsha512.js"></script>
<script>

var downloadEle = document.getElementById('downloadEle');
var mapDiv = document.getElementById('mapDiv');
function dsHash(data){
    var shaObj = new jsSHA(data, "TEXT");
    return shaObj.getHash("SHA-512", "HEX").substr(0,20);
    //return hashlib.sha512(data).hexdigest()[0:20]
}
function dhHashId(Id){
    fi=bridge.getPeerDetails(Id);
    return dsHash(dsHash(fi['id'])+dsHash(fi['name']));
    }
var myOwnHash = dhHashId(bridge.getOwnId());
var friendIds = bridge.getFriendList();
var friendHashs = {};
$.each(friendIds, function(key, value){
friendHashs[dhHashId(value)]=value;
})
console.log(myOwnHash)
var width = 960,
    height = 500;

var color = d3.scale.category20();

var force = d3.layout.force()
    //.charge(30)
    .size([width, height]);

var svg = d3.select("body").select("div#mapDiv").append("svg")
    .attr("width", width)
    .attr("height", height);


var links = [];
var nodes = [];
var nodesDict = {}
var handledCount = 0;

function chartFromLocalSearch(){
  searchOptions = {"localindexed":true,"remoteindexed":false,"boolexp":false};
  var sresult = bridge.searchKeywords("global-peer-map-from", searchOptions);
  //console.log(JSON.stringify(sresult))
  var results = sresult.results;

  filesList = [
  //bridge.getDownloadDirectory()+"/global-peer-map-from-14758448e1fe21b6ba3d.json",
  //bridge.getDownloadDirectory()+"/global-peer-map-from-58eb72735298614b92e1.json"
  ]
  for (r in results){
  filesList.push(results[r].fullpath+results[r].srname);
  }
  handledCount = 0;
  for (f in filesList){
    $.getJSON(filesList[f], handleFile)
  }
}

function ownFileNotFound(){
        console.log("owen file not found - generating");
        bridge.runPythonFile('python/dumpanonconnections.py')
        downloadMore();
        window.alert("first run - wait a little for info to gather, and refresh");
}

var fname =bridge.getDownloadDirectory()+"/global-peer-map-from-"+myOwnHash+".json"
console.log(fname);
$.ajax({
    url:fname,
    dataType: "json",
    error: function(asd)
    {
    ownFileNotFound();
    },
    success: function(asd)
    {
        if (asd == null)
          ownFileNotFound();
        else{
          console.log("Own file found");
          //console.log("done: "+JSON.stringify(asd));
          handleFileInternal(asd);
          downloadMore();
          chartFromLocalSearch();
        }
    }
});//*/



function checkAddNode(hash){
  if (!nodesDict.hasOwnProperty(hash)){
    var name = hash.substr(0,5);
    if(hash==myOwnHash)name="ME";
    if(friendHashs.hasOwnProperty(hash))name=bridge.getPeerName(friendHashs[hash]).substr(0,10);
    nodes.push({"name":name});
    nodesDict[hash]=nodes.length-1;
    }
  return nodesDict[hash]
}
function handleFileInternal(graph){
//console.log(graph)
graph.links = [];
var ownindex =checkAddNode(graph.ownHash);
for (var l = 0;l <graph.contactHashes.length;l++){
  var otherindex = checkAddNode(graph.contactHashes[l])
  //console.log(ownindex+" : "+otherindex)
  if(ownindex!=otherindex)
  links.push({"source":ownindex,"target":otherindex});
  }
}
function handleFile(graph){
  handleFileInternal(graph)
  handledCount+=1;
  if(handledCount>=filesList.length)doGraph();
}
function doGraph(){

  force
      .nodes(nodes)
      .links(links)
      .linkStrength(0.2)
      .charge(-600)
      .linkDistance(80)
      .start();
  
  var link = svg.selectAll(".link")
      .data(links)
    .enter().append("line")
      .attr("class", "link")
      .style("stroke-width", function(d) { return 2; });

  /*var node = svg.selectAll(".node")
      .data(nodes)
    .enter().append("circle")
      .attr("class", "node")
      .attr("r", 6)
      .style("fill", function(d) { return color(6); })
      .call(force.drag);*/
  // Create the groups under svg
var gnodes = svg.selectAll('g.gnode')
  .data(nodes)
  .enter()
  .append('g')
  .classed('gnode', true);

// Add one circle in each group
var node = gnodes.append("circle")
  .attr("class", "node")
  .attr("r", 7)
  .style("fill", function(d) { return color(6); })//d.group
  .call(force.drag);

// Append the labels to each group
var labels = gnodes.append("text")
  .text(function(d) { return d.name; });

  //node.append("title")
  //  .text(function(d) { return d.name; });

  force.on("tick", function() {
    link.attr("x1", function(d) { return d.source.x; })
        .attr("y1", function(d) { return d.source.y; })
        .attr("x2", function(d) { return d.target.x; })
        .attr("y2", function(d) { return d.target.y; });

  // Translate the groups
  gnodes.attr("transform", function(d) { 
    return 'translate(' + [d.x, d.y] + ')'; 
  });    
  });
}

function downloadMore(){
  searchOptions = {"localindexed":false,"remoteindexed":true,"turtle":true,"boolexp":false};
  var sresult = bridge.searchKeywords("global-peer-map-from", searchOptions);
  var results = sresult.results;
  downloadEle.innerHTML = ""
  for (var i in results){
    
        var qname = results[i].srname;
        var qsize = results[i].size;
        var qhash = +results[i].hash;
    var result = bridge.downloadFile(qname, qhash, qsize);
    if (result.status != "downloaded"){
    downloadEle.innerHTML+="Downloading: "+qname+"<br>";
      //var finalpath = getFinalPath(result.path, result.fname);
    }
    
  }
  if(downloadEle.innerHTML == "")
    downloadEle.innerHTML = "No New Peers found in index - please wait for turtle search<br>"
  else
    downloadEle.innerHTML += "Downloading new! please refresh when downloads complete<br>"
}

bridge.rsTurtleResult.connect(rsTurtleResult);
function rsTurtleResult(result){
  //console.log("running turtleresult");
  //console.log(result);
  if (result.name.substr(0,20) == "global-peer-map-from" && result.status =="notdownloaded" ){
    downloadEle.innerHTML += "Downloading: "+result.name+"<br>"
    var result = bridge.downloadFile(result.name, result.hash, result.size);
  }
    
}
</script>

</body>
</html>
