<!DOCTYPE html>
<html lang="en">
        <head>
                <title>three.js webgl - geometry - cube</title>
                <meta charset="utf-8">
                <style>
                        body {
                                margin: 0px;
                                background-color: #00000f;
                                overflow: hidden;
                        }
                </style>
        </head>
        <body>
              
                <script src="three.min.js"></script>

                <script>

                        var camera, scene, renderer;
                        var mesh, mesher;
                        var camzpos = 400;
                        var isMouseDown= false;
                        
                        var balls = [];
                        

                        init();
                        animate();

                        function init() {

                                renderer = new THREE.WebGLRenderer();
                                renderer.setSize( window.innerWidth, window.innerHeight );
                                document.body.appendChild( renderer.domElement );

                                //

                                camera = new THREE.PerspectiveCamera( 90, window.innerWidth / window.innerHeight, 1, 1000 );
                                camera.position.z = camzpos;
                                
                                x = camera;
                                y = camzpos;
                                
                                //camera.position.y = 100;

                                scene = new THREE.Scene();

                                var geometry = new THREE.CubeGeometry( 200, 200, 100 );
                                var sgeom = new THREE.SphereGeometry( 200 ,30,30);
                                //var texture = THREE.ImageUtils.loadTexture( 'textures/crate.gif' );
                                //texture.anisotropy = renderer.getMaxAnisotropy();

                                var material = new THREE.MeshPhongMaterial( { ambient: 0x030303, color: 0xdddddd, specular: 0x009900, shininess: 90, shading: THREE.FlatShading } );
                                //new THREE.MeshPhongMaterial( { color: 0x000000, specular: 0x666666, emissive: 0xff0000, ambient: 0x000000, shininess: 10, shading: THREE.SmoothShading, opacity: 0.9, transparent: true } );
                                //new THREE.MeshBasicMaterial( { map: texture } );

                                mesh = new THREE.Mesh( geometry, material );
                                scene.add( mesh );
                                mesh.position.x = 200
                                
                                mesher = new THREE.Mesh( sgeom, material );
                                scene.add( mesher );

                                //
                                // Lights

                                scene.add( new THREE.AmbientLight( 0x111111 ) );

                                var directionalLight = new THREE.DirectionalLight( /*Math.random() * */ 0xffffff, 0.425 );

                                directionalLight.position.x = 0 - 0.5;
                                directionalLight.position.y = 0.5;
                                directionalLight.position.z = 0.5;//Math.random() - 0.5;

                                directionalLight.position.normalize();

                                scene.add( directionalLight );

                                pointLight = new THREE.PointLight( 0xffffff, 1 );
                                pointLight.position.x = 0;
                                pointLight.position.y = 0;
                                pointLight.position.z = 0;
                                //scene.add( pointLight );

                                window.addEventListener( 'resize', onWindowResize, false );
                                
                                document.addEventListener( 'mousemove', onDocumentMouseMove, false );

                        }

                        function onWindowResize() {

                                camera.aspect = window.innerWidth / window.innerHeight;
                                camera.updateProjectionMatrix();

                                renderer.setSize( window.innerWidth, window.innerHeight );

                        }

                        function animate() {

                                requestAnimationFrame( animate );

                                mesh.rotation.x += 0.005;
                                mesh.rotation.y += 0.01;
                                
                                //mesher.rotation.x+=0.005;
                                //mesher.scale.y*=0.95;

                                renderer.render( scene, camera );

                        }
                        
                        function onDocumentMouseMove( event ) {

                              event.preventDefault();
                              mesher.scale.y=event.clientY*0.001;
                              mesher.scale.x=event.clientY*0.001;
                              mesher.scale.z=event.clientY*0.001;
                              
                              mesher.rotation.y = event.clientX*0.01;
                              /*if ( isMouseDown ) {

                                  theta = - ( ( event.clientX - onMouseDownPosition.x ) * 0.5 )
                                          + onMouseDownTheta;
                                  phi = ( ( event.clientY - onMouseDownPosition.y ) * 0.5 )
                                        + onMouseDownPhi;

                                  phi = Math.min( 180, Math.max( 0, phi ) );

                                  camera.position.x = radious * Math.sin( theta * Math.PI / 360 )
                                                      * Math.cos( phi * Math.PI / 360 );
                                  camera.position.y = radious * Math.sin( phi * Math.PI / 360 );
                                  camera.position.z = radious * Math.cos( theta * Math.PI / 360 )
                                                      * Math.cos( phi * Math.PI / 360 );
                                  camera.updateMatrix();

                              }*/

                              /*mouse3D = projector.unprojectVector(
                                  new THREE.Vector3(
                                      ( event.clientX / renderer.domElement.width ) * 2 - 1,
                                      - ( event.clientY / renderer.domElement.height ) * 2 + 1,
                                      0.5
                                  ),
                                  camera
                              );
                              ray.direction = mouse3D.subSelf( camera.position ).normalize();

                              interact();
                              render();*/

                          }

                </script>

        </body>
</html>
